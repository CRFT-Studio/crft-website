---
import { parseStringPromise } from 'xml2js';

const { url } = Astro.props;

let sitemapUrls: string[] = [];

if (url) {
  const baseUrl = new URL(url).origin;

  // Helper function to fetch and parse sitemap
  async function processSitemap(url: string): Promise<string[]> {
    const response = await fetch(url);
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

    const text = await response.text();
    const urls = new Set<string>();

    try {
      const result = await parseStringPromise(text);

      // Handle sitemap index
      if (result.sitemapindex) {
        const sitemaps = result.sitemapindex.sitemap || [];
        for (const sitemap of sitemaps) {
          if (sitemap.loc && sitemap.loc[0]) {
            const subSitemapUrls = await processSitemap(sitemap.loc[0]);
            subSitemapUrls.forEach(url => urls.add(url));
          }
        }
      }
      // Handle regular sitemap
      else if (result.urlset) {
        const urlElements = result.urlset.url || [];
        for (const urlElement of urlElements) {
          if (urlElement.loc && urlElement.loc[0]) {
            urls.add(urlElement.loc[0]);
          }
        }
      }
    } catch (error) {
      console.error('Error parsing XML:', error);
    }

    return Array.from(urls);
  }

  try {
    // First try robots.txt
    const robotsResponse = await fetch(`${baseUrl}/robots.txt`);
    if (robotsResponse.ok) {
      const robotsText = await robotsResponse.text();
      const sitemapMatches = robotsText.matchAll(/Sitemap:\s*(.+)/gi);

      for (const match of sitemapMatches) {
        const sitemapUrl = match[1].trim();
        const urls = await processSitemap(sitemapUrl);
        sitemapUrls = [...sitemapUrls, ...urls];
      }
    }

    // If no URLs found, try common paths
    if (sitemapUrls.length === 0) {
      const COMMON_SITEMAP_PATHS = [
        '/sitemap.xml',
        '/sitemap_index.xml',
        '/sitemap-index.xml',
        '/sitemap/sitemap.xml',
        '/sitemap-0.xml',
        '/sitemap.php',
        '/sitemap/index.xml'
      ];

      for (const path of COMMON_SITEMAP_PATHS) {
        try {
          const urls = await processSitemap(`${baseUrl}${path}`);
          if (urls.length > 0) {
            sitemapUrls = urls;
            break;
          }
        } catch (error) {
          continue;
        }
      }
    }
  } catch (error) {
    console.error('Error fetching sitemap:', error);
  }
}
---
<div id="sitemap-container" class="square-card p-4 relative">
  <button id="reset-view" class="square-card absolute top-4 right-4 px-3 py-1 z-10">
    Reset position
  </button>
  <div id="sitemap-viz" class="w-full h-[600px] overflow-hidden"></div>
</div>

<script type="module" define:vars={{ url, sitemapUrls }}>
import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

function transformToHierarchy(urls, baseUrl) {
  const root = {
    name: baseUrl,
    children: []
  };

  urls.forEach(url => {
    let path = url.replace(/^https?:\/\/[^/]+/, '');
    const segments = path.split('/').filter(Boolean);

    let current = root;
    segments.forEach(segment => {
      let child = current.children.find(c => c.name === segment);
      if (!child) {
        child = { name: segment, children: [] };
        current.children.push(child);
      }
      current = child;
    });
  });

  return root;
}

function visualizeSitemap(data) {
  const isDesktop = () => window.innerWidth >= 1024;

  function updateVisualization() {
    d3.select('#sitemap-viz').html('');

    const container = document.getElementById('sitemap-viz');
    const width = container.clientWidth;
    const height = container.clientHeight;

    const svg = d3.select('#sitemap-viz')
      .append('svg')
      .attr('width', '100%')
      .attr('height', '100%')
      .style('cursor', 'grab');

    const g = svg.append('g');

    const zoom = d3.zoom()
      .scaleExtent([0.1, 4])
      .on('zoom', (event) => {
        g.attr('transform', event.transform);
      });

    svg.call(zoom);

    const treeLayout = d3.tree()
      .nodeSize(isDesktop() ? [40, 120] : [120, 40]);

    const root = d3.hierarchy(data);
    const treeData = treeLayout(root);

    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;

    root.each(d => {
      if (!isDesktop()) {  // Swap coordinates for desktop (horizontal) layout
        const temp = d.x;
        d.x = d.y;
        d.y = temp;
      }
      minX = Math.min(minX, d.x);
      maxX = Math.max(maxX, d.x);
      minY = Math.min(minY, d.y);
      maxY = Math.max(maxY, d.y);
    });

    g.selectAll('.link')
      .data(treeData.links())
      .enter()
      .append('path')
      .attr('class', 'link')
      .attr('stroke', '#ffffff')
      .attr('stroke-width', '1.5px')
      .attr('fill', 'none')
      .attr('opacity', '0.4')
      .attr('d', d => {
        if (isDesktop()) {  // Horizontal curves for desktop
          return `M${d.source.x},${d.source.y}
                  C${d.source.x},${(d.source.y + d.target.y) / 2}
                   ${d.target.x},${(d.source.y + d.target.y) / 2}
                   ${d.target.x},${d.target.y}`;
        } else {  // Vertical curves for mobile
          return `M${d.source.x},${d.source.y}
                  C${(d.source.x + d.target.x) / 2},${d.source.y}
                   ${(d.source.x + d.target.x) / 2},${d.target.y}
                   ${d.target.x},${d.target.y}`;
        }
    });

    const nodes = g.selectAll('.node')
      .data(treeData.descendants())
      .enter()
      .append('g')
      .attr('class', 'node')
      .attr('transform', d => `translate(${d.x},${d.y})`);

    nodes.append('circle')
      .attr('r', 6)
      .attr('fill', '#f97316')
      .attr('stroke', '#ffffff')
      .attr('stroke-width', '2px');

    nodes.append('text')
      .attr('dy', '0.31em')
      .attr('x', d => !isDesktop() ? 8 : 0)
      .attr('y', d => !isDesktop() ? 0 : 16)
      .attr('text-anchor', d => !isDesktop() ? 'start' : 'middle')
      .attr('fill', '#ffffff')
      .text(d => d.data.name);

    const initialTransform = d3.zoomIdentity
      .translate(
        isDesktop() ? width * 0.2 : width / 2,
        isDesktop() ? height / 2 : height * 0.2
      )
      .scale(isDesktop() ? 0.8 : 0.4);

    svg.call(zoom.transform, initialTransform);

    document.getElementById('reset-view').onclick = () => {
      svg.transition()
        .duration(750)
        .call(zoom.transform, initialTransform);
    };

    svg.on('dblclick.zoom', null);
  }

  // Initial visualization
  updateVisualization();

  // Update on window resize
  let resizeTimer;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(() => {
      updateVisualization();
    }, 250);
  });
}

if (url && sitemapUrls.length > 0) {
  const baseUrl = new URL(url).origin;
  const hierarchyData = transformToHierarchy(sitemapUrls, baseUrl);
  visualizeSitemap(hierarchyData);
} else {
  document.getElementById('sitemap-viz').innerHTML =
    '<div class="text-neutral-300 flex items-center justify-center h-full">No sitemap found or sitemap is empty</div>';
}
</script>

<style>
#sitemap-viz {
  background: #1c1c1c;
  border-radius: 4px;
}

#sitemap-viz svg {
  display: block;
}

#reset-view {
  color: #ffffff;
  background: #262626;
  transition: background-color 0.2s;
  font-size: 14px;
  border-radius: 4px;
  border: 1px solid #404040;
}

#reset-view:hover {
  background: #404040;
}

@media (max-width: 768px) {
  #reset-view {
    top: auto;
    bottom: 1rem;
    right: 1rem;
  }
}
</style>
