---
import { parseStringPromise } from 'xml2js';

const { url } = Astro.props;

let sitemapUrls: string[] = [];

if (url) {
  const baseUrl = new URL(url).origin;

  // Helper function to fetch and parse sitemap
  async function processSitemap(url: string): Promise<string[]> {
    const response = await fetch(url);
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

    const text = await response.text();
    const urls = new Set<string>();

    try {
      const result = await parseStringPromise(text);

      // Handle sitemap index
      if (result.sitemapindex) {
        const sitemaps = result.sitemapindex.sitemap || [];
        for (const sitemap of sitemaps) {
          if (sitemap.loc && sitemap.loc[0]) {
            const subSitemapUrls = await processSitemap(sitemap.loc[0]);
            subSitemapUrls.forEach(url => urls.add(url));
          }
        }
      }
      // Handle regular sitemap
      else if (result.urlset) {
        const urlElements = result.urlset.url || [];
        for (const urlElement of urlElements) {
          if (urlElement.loc && urlElement.loc[0]) {
            urls.add(urlElement.loc[0]);
          }
        }
      }
    } catch (error) {
      console.error('Error parsing XML:', error);
    }

    return Array.from(urls);
  }

  try {
    // First try robots.txt
    const robotsResponse = await fetch(`${baseUrl}/robots.txt`);
    if (robotsResponse.ok) {
      const robotsText = await robotsResponse.text();
      const sitemapMatches = robotsText.matchAll(/Sitemap:\s*(.+)/gi);

      for (const match of sitemapMatches) {
        const sitemapUrl = match[1].trim();
        const urls = await processSitemap(sitemapUrl);
        sitemapUrls = [...sitemapUrls, ...urls];
      }
    }

    // If no URLs found, try common paths
    if (sitemapUrls.length === 0) {
      const COMMON_SITEMAP_PATHS = [
        '/sitemap.xml',
        '/sitemap_index.xml',
        '/sitemap-index.xml',
        '/sitemap/sitemap.xml',
        '/sitemap-0.xml',
        '/sitemap.php',
        '/sitemap/index.xml'
      ];

      for (const path of COMMON_SITEMAP_PATHS) {
        try {
          const urls = await processSitemap(`${baseUrl}${path}`);
          if (urls.length > 0) {
            sitemapUrls = urls;
            break;
          }
        } catch (error) {
          continue;
        }
      }
    }
  } catch (error) {
    console.error('Error fetching sitemap:', error);
  }
}
---
<div id="sitemap-container" class="square-card p-4 relative">
  <button id="reset-view" class="square-card absolute top-4 right-4 px-3 py-1 z-10">
    Reset position
  </button>
  <div id="sitemap-viz" class="w-full h-[600px] overflow-hidden"></div>
</div>

<script type="module" define:vars={{ url, sitemapUrls }}>
import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

function transformToHierarchy(urls, baseUrl) {
  const root = {
    name: baseUrl,
    children: []
  };

  urls.forEach(url => {
    let path = url.replace(/^https?:\/\/[^/]+/, '');
    const segments = path.split('/').filter(Boolean);

    let current = root;
    segments.forEach(segment => {
      let child = current.children.find(c => c.name === segment);
      if (!child) {
        child = { name: segment, children: [] };
        current.children.push(child);
      }
      current = child;
    });
  });

  return root;
}

function visualizeSitemap(data) {
  d3.select('#sitemap-viz').html('');

  const container = document.getElementById('sitemap-viz');
  const width = container.clientWidth;
  const height = container.clientHeight;

  const svg = d3.select('#sitemap-viz')
    .append('svg')
    .attr('width', '100%')
    .attr('height', '100%')
    .style('cursor', 'grab');

  const g = svg.append('g');

  const zoom = d3.zoom()
    .scaleExtent([0.1, 4])
    .on('zoom', (event) => {
      g.attr('transform', event.transform);
    });

  svg.call(zoom);

  // Responsive tree layout based on screen width
  const treeLayout = d3.tree()
    .nodeSize(window.innerWidth >= 1024 ? [40, 120] : [120, 40])
    .separation((a, b) => a.parent === b.parent ? 1.5 : 2);

  const root = d3.hierarchy(data);
  const treeData = treeLayout(root);

  // Calculate bounds
  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  root.each(d => {
    if (window.innerWidth >= 1024) {
      // Horizontal layout
      minX = Math.min(minX, d.x);
      maxX = Math.max(maxX, d.x);
      minY = Math.min(minY, d.y);
      maxY = Math.max(maxY, d.y);
    } else {
      // Vertical layout
      minX = Math.min(minX, d.y);
      maxX = Math.max(maxX, d.y);
      minY = Math.min(minY, d.x);
      maxY = Math.max(maxY, d.x);
    }
  });

  // Add links (straight lines)
  g.selectAll('.link')
    .data(treeData.links())
    .enter()
    .append('path')
    .attr('class', 'link')
    .attr('d', d => {
      if (window.innerWidth >= 1024) {
        return `M${d.source.y},${d.source.x}L${d.target.y},${d.target.x}`;
      } else {
        return `M${d.source.x},${d.source.y}L${d.target.x},${d.target.y}`;
      }
    });

  // Add nodes
  const nodes = g.selectAll('.node')
    .data(treeData.descendants())
    .enter()
    .append('g')
    .attr('class', 'node')
    .attr('transform', d => {
      if (window.innerWidth >= 1024) {
        return `translate(${d.y},${d.x})`;
      } else {
        return `translate(${d.x},${d.y})`;
      }
    });

  nodes.append('circle')
    .attr('r', 6);

  nodes.append('text')
    .attr('dy', '0.31em')
    .attr('x', d => {
      if (window.innerWidth >= 1024) {
        return d.children ? -10 : 10;
      } else {
        return 10;
      }
    })
    .attr('text-anchor', d => {
      if (window.innerWidth >= 1024) {
        return d.children ? 'end' : 'start';
      } else {
        return 'start';
      }
    })
    .text(d => d.data.name);

  // Calculate and apply initial transform
  const treeWidth = maxX - minX;
  const treeHeight = maxY - minY;
  const scale = Math.min(
    width / (treeWidth + 200),
    height / (treeHeight + 100),
    1
  );

  const initialTransform = d3.zoomIdentity
    .translate(width / 2 - (treeWidth * scale) / 2, height / 2)
    .scale(scale);

  // Apply initial transform
  svg.call(zoom.transform, initialTransform);

  // Reset button handler
  document.getElementById('reset-view').onclick = () => {
    svg.transition()
      .duration(750)
      .call(zoom.transform, initialTransform);
  };

  // Remove double-click to reset (since we now have a button)
  svg.on('dblclick.zoom', null);
}

if (url && sitemapUrls.length > 0) {
  const baseUrl = new URL(url).origin;
  const hierarchyData = transformToHierarchy(sitemapUrls, baseUrl);
  visualizeSitemap(hierarchyData);
} else {
  document.getElementById('sitemap-viz').innerHTML =
    '<div class="text-neutral-300 flex items-center justify-center h-full">No sitemap found or sitemap is empty</div>';
}
</script>

<style>
.node circle {
  fill: #f97316;
  stroke: #fff;
  stroke-width: 1.5px;
}

.node text {
  font: 14px system-ui, sans-serif;
  fill: #fff;
  user-select: none;
}

.link {
  fill: none;
  stroke: #666;
  stroke-width: 1.5px;
}

#sitemap-viz {
  background: #1c1c1c;
  border-radius: 4px;
}

#sitemap-viz svg {
  display: block;
}

#sitemap-viz text {
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

#reset-view {
  color: #fff;
  background: #262626;
  transition: background-color 0.2s;
}

#reset-view:hover {
  background: #404040;
}
</style>
