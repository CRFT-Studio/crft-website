---
import { parseStringPromise } from 'xml2js';

const { url } = Astro.props;

let sitemapUrls: string[] = [];

if (url) {
  const baseUrl = new URL(url).origin;

  // Helper function to fetch and parse sitemap
  async function processSitemap(url: string): Promise<string[]> {
    const response = await fetch(url);
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

    const text = await response.text();
    const urls = new Set<string>();

    try {
      const result = await parseStringPromise(text);

      // Handle sitemap index
      if (result.sitemapindex) {
        const sitemaps = result.sitemapindex.sitemap || [];
        for (const sitemap of sitemaps) {
          if (sitemap.loc && sitemap.loc[0]) {
            const subSitemapUrls = await processSitemap(sitemap.loc[0]);
            subSitemapUrls.forEach(url => urls.add(url));
          }
        }
      }
      // Handle regular sitemap
      else if (result.urlset) {
        const urlElements = result.urlset.url || [];
        for (const urlElement of urlElements) {
          if (urlElement.loc && urlElement.loc[0]) {
            urls.add(urlElement.loc[0]);
          }
        }
      }
    } catch (error) {
      console.error('Error parsing XML:', error);
    }

    return Array.from(urls);
  }

  try {
    // First try robots.txt
    const robotsResponse = await fetch(`${baseUrl}/robots.txt`);
    if (robotsResponse.ok) {
      const robotsText = await robotsResponse.text();
      const sitemapMatches = robotsText.matchAll(/Sitemap:\s*(.+)/gi);

      for (const match of sitemapMatches) {
        const sitemapUrl = match[1].trim();
        const urls = await processSitemap(sitemapUrl);
        sitemapUrls = [...sitemapUrls, ...urls];
      }
    }

    // If no URLs found, try common paths
    if (sitemapUrls.length === 0) {
      const COMMON_SITEMAP_PATHS = [
        '/sitemap.xml',
        '/sitemap_index.xml',
        '/sitemap-index.xml',
        '/sitemap/sitemap.xml',
        '/sitemap-0.xml',
        '/sitemap.php',
        '/sitemap/index.xml'
      ];

      for (const path of COMMON_SITEMAP_PATHS) {
        try {
          const urls = await processSitemap(`${baseUrl}${path}`);
          if (urls.length > 0) {
            sitemapUrls = urls;
            break;
          }
        } catch (error) {
          continue;
        }
      }
    }
  } catch (error) {
    console.error('Error fetching sitemap:', error);
  }
}
---
<div id="sitemap-container" class="square-card p-4 relative">
  <button id="reset-view" class="square-card absolute top-4 right-4 px-3 py-1 z-10">
    Reset position
  </button>
  <div id="sitemap-viz" class="w-full h-[600px] overflow-hidden"></div>
</div>

<script type="module" define:vars={{ url, sitemapUrls }}>
import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

document.addEventListener('DOMContentLoaded', () => {
  function transformToHierarchy(urls, baseUrl) {
    const root = {
      name: baseUrl,
      children: []
    };

    urls.forEach(url => {
      let path = url.replace(/^https?:\/\/[^/]+/, '');
      const segments = path.split('/').filter(Boolean);

      let current = root;
      segments.forEach(segment => {
        let child = current.children.find(c => c.name === segment);
        if (!child) {
          child = { name: segment, children: [] };
          current.children.push(child);
        }
        current = child;
      });
    });

    return root;
  }

  function visualizeSitemap(data) {
    const isDesktop = () => window.innerWidth >= 1024;

    function updateVisualization() {
      d3.select('#sitemap-viz').html('');

      const container = document.getElementById('sitemap-viz');
      const width = container.clientWidth;
      const height = container.clientHeight;

      const svg = d3.select('#sitemap-viz')
        .append('svg')
        .attr('width', '100%')
        .attr('height', '100%')
        .style('cursor', 'grab');

      const g = svg.append('g');

      const zoom = d3.zoom()
        .scaleExtent([0.1, 4])
        .on('zoom', (event) => {
          g.attr('transform', event.transform);
        });

      svg.call(zoom);

      const treeLayout = d3.tree()
        .nodeSize(isDesktop() ? [80, 180] : [120, 40])
        .separation((a, b) => {
          // Create temporary elements to measure text widths
          const tempA = document.createElement('span');
          tempA.textContent = a.data.name;
          const tempB = document.createElement('span');
          tempB.textContent = b.data.name;
          document.body.appendChild(tempA);
          document.body.appendChild(tempB);

          // Calculate base separation based on text lengths
          const widthA = tempA.offsetWidth;
          const widthB = tempB.offsetWidth;
          document.body.removeChild(tempA);
          document.body.removeChild(tempB);

          // Base separation on the longer text
          const baseSpacing = Math.max(widthA, widthB) / 50;

          if (!isDesktop()) {
            // For mobile vertical layout
            return a.parent === b.parent ?
              Math.max(1.2, baseSpacing) : // Sibling spacing
              Math.max(2.5, baseSpacing * 1.5); // Different parent spacing
          } else {
            // For desktop horizontal layout
            return a.parent === b.parent ?
              Math.max(1, baseSpacing) : // Sibling spacing
              Math.max(1, baseSpacing * 1.2); // Different parent spacing
          }
        });

      const root = d3.hierarchy(data);
      const treeData = treeLayout(root);

      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;

      root.each(d => {
        if (!isDesktop()) {
          const temp = d.x;
          d.x = d.y;
          d.y = temp;
        }
        minX = Math.min(minX, d.x);
        maxX = Math.max(maxX, d.x);
        minY = Math.min(minY, d.y);
        maxY = Math.max(maxY, d.y);
      });

      g.selectAll('.link')
        .data(treeData.links())
        .enter()
        .append('path')
        .attr('class', 'link')
        .attr('stroke', '#ffffff')
        .attr('stroke-width', '1.5px')
        .attr('fill', 'none')
        .attr('opacity', '0.4')
        .attr('d', d => {
          if (isDesktop()) {
            return `M${d.source.x},${d.source.y}
                    C${d.source.x},${(d.source.y + d.target.y) / 2}
                     ${d.target.x},${(d.source.y + d.target.y) / 2}
                     ${d.target.x},${d.target.y}`;
          } else {
            return `M${d.source.x},${d.source.y}
                    C${(d.source.x + d.target.x) / 2},${d.source.y}
                     ${(d.source.x + d.target.x) / 2},${d.target.y}
                     ${d.target.x},${d.target.y}`;
          }
        });

      const nodes = g.selectAll('.node')
        .data(treeData.descendants())
        .enter()
        .append('g')
        .attr('class', 'node')
        .attr('transform', d => `translate(${d.x},${d.y})`);

      nodes.append('circle')
        .attr('r', 6)
        .attr('fill', '#f97316')
        .attr('stroke', '#ffffff')
        .attr('stroke-width', '2px');

      nodes.append('foreignObject')
        .attr('x', d => isDesktop() ? 8 : -60)
        .attr('y', d => isDesktop() ? -12 : 16)
        .attr('width', d => {
          const temp = document.createElement('span');
          temp.className = 'square-card px-2 py-1';
          temp.textContent = d.data.name;
          document.body.appendChild(temp);
          const width = temp.offsetWidth;
          document.body.removeChild(temp);
          return width + 20;
        })
        .attr('height', 30)
        .append('xhtml:div')
        .attr('class', 'square-card px-2 py-1')
        .style('color', '#ffffff')
        .style('background', '#262626')
        .style('border-radius', '4px')
        .style('display', 'inline-block')
        .text(d => d.data.name);

      const initialTransform = d3.zoomIdentity
        .translate(
          isDesktop() ? width * 0.2 : width / 2,
          isDesktop() ? height / 2 : height * 0.2
        )
        .scale(isDesktop() ? 0.8 : 0.4);

      svg.call(zoom.transform, initialTransform);

      document.getElementById('reset-view').onclick = () => {
        svg.transition()
          .duration(750)
          .call(zoom.transform, initialTransform);
      };

      svg.on('dblclick.zoom', null);
    }

    // Initial visualization
    updateVisualization();

    // Update on window resize
    let resizeTimer;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => {
        updateVisualization();
      }, 250);
    });
  }

  if (url && sitemapUrls.length > 0) {
    const baseUrl = new URL(url).origin;
    const hierarchyData = transformToHierarchy(sitemapUrls, baseUrl);
    visualizeSitemap(hierarchyData);
  } else {
    document.getElementById('sitemap-viz').innerHTML =
      '<div class="text-neutral-300 flex items-center justify-center h-full">No sitemap found or sitemap is empty</div>';
  }
});
</script>

<style>
#sitemap-viz {
  background: #1c1c1c;
  border-radius: 4px;
}

#sitemap-viz svg {
  display: block;
}

#reset-view {
  color: #ffffff;
  background: #262626;
  transition: background-color 0.2s;
  font-size: 14px;
  border-radius: 4px;
  border: 1px solid #404040;
}

#reset-view:hover {
  background: #404040;
}

@media (max-width: 768px) {
  #reset-view {
    top: auto;
    bottom: 1rem;
    right: 1rem;
  }
}
</style>
